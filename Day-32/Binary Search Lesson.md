

**ChatGPT:**
<p>Hereâ€™s an expansive lesson plan for teaching your students how to implement <strong>binary search</strong> on a sorted array of numbers in JavaScript. This lesson covers the theory, implementation, and step-by-step breakdown of the binary search algorithm.</p><h3><strong>Lesson Objective</strong></h3><p>By the end of this lesson, students will:</p><ol><li>Understand the concept of binary search and how it differs from linear search.</li><li>Learn how to implement binary search using iteration and recursion.</li><li>Recognize the efficiency of binary search in terms of time complexity.</li></ol><h3><strong>Lesson Plan Breakdown</strong></h3><ol><li><p><strong>Introduction to Binary Search (5 minutes)</strong></p><ul><li><strong>What is Binary Search?</strong>
Binary search is an efficient algorithm for finding an element in a sorted array. Instead of searching the array element by element (linear search), binary search divides the array in half repeatedly, eliminating half of the remaining elements with each comparison.</li><li><strong>Conditions:</strong>
Emphasize that <strong>binary search only works on sorted arrays</strong>.</li><li><strong>Key Concepts:</strong><ul><li><strong>Divide and conquer</strong> approach.</li><li>Efficiency improvement over linear search.</li></ul></li><li><strong>Real-world analogy:</strong>
Compare binary search to finding a name in a phone book. Instead of starting at the first name and flipping through one by one, you open the book in the middle, check if the name is before or after, and then focus on one half of the book.</li></ul><p><strong>Linear Search Recap:</strong>
Before diving into binary search, quickly recap linear search to contrast how much faster binary search can be.</p><p><strong>Example Linear Search:</strong></p><pre class="!overflow-visible"><div class="dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative"><div class="flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9">javascript</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center py-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy code</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">linearSearch</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">if</span> (arr[i] === target) {
            <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// Return the index if found</span>
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// Return -1 if not found</span>
}

<span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">linearSearch</span>(numbers, <span class="hljs-number">7</span>)); <span class="hljs-comment">// Output: 6</span>
</code></div></div></pre><p><strong>Time Complexity of Linear Search:</strong></p><ul><li><strong>O(n)</strong>: In the worst case, linear search checks each element until the target is found or the array ends.</li></ul></li><li><p><strong>Binary Search Concept (5 minutes)</strong></p><p><strong>Binary Search Logic:</strong></p><ol><li>Start with two pointers: one at the beginning (<code>low</code>) and one at the end (<code>high</code>) of the array.</li><li>Calculate the middle index of the array.</li><li>Compare the middle element with the target:<ul><li>If the middle element is equal to the target, return its index.</li><li>If the target is smaller than the middle element, discard the right half of the array by adjusting <code>high</code>.</li><li>If the target is larger than the middle element, discard the left half by adjusting <code>low</code>.</li></ul></li><li>Repeat the process until the target is found or the array cannot be divided further.</li></ol><p><strong>Example Sorted Array:</strong></p><pre class="!overflow-visible"><div class="dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative"><div class="flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9">javascript</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center py-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy code</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
<span class="hljs-keyword">let</span> target = <span class="hljs-number">7</span>;
</code></div></div></pre><p>Walk through how the algorithm repeatedly divides the array, searching for the target number (7). Show how the array shrinks in size after each iteration.</p><p><strong>Visual Aid:</strong></p><ul><li>Show the sorted array on a whiteboard or slide, drawing a line through the middle each time, and highlighting the part of the array being eliminated.</li></ul></li><li><p><strong>Binary Search (Iterative Implementation) (5 minutes)</strong></p><p><strong>Code Example:</strong></p><pre class="!overflow-visible"><div class="dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative"><div class="flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9">javascript</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center py-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy code</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {
    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> high = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (low &lt;= high) {
        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((low + high) / <span class="hljs-number">2</span>); <span class="hljs-comment">// Find the middle index</span>

        <span class="hljs-keyword">if</span> (arr[mid] === target) {
            <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">// Target found</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
            low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// Focus on the right half</span>
        } <span class="hljs-keyword">else</span> {
            high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// Focus on the left half</span>
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// Target not found</span>
}

<span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">binarySearch</span>(numbers, <span class="hljs-number">7</span>)); <span class="hljs-comment">// Output: 6</span>
</code></div></div></pre><p><strong>Walkthrough:</strong></p><ul><li>Start with <code>low = 0</code> and <code>high = 8</code> (the length of the array minus 1).</li><li>Calculate the middle index: <code>(0 + 8) / 2 = 4</code>. The middle element is <code>5</code>.</li><li>Since <code>7 &gt; 5</code>, move <code>low</code> to <code>5</code> and repeat the process.</li><li>Continue dividing until the target is found or the array size becomes 0.</li></ul><p><strong>Detailed Breakdown:</strong></p><ul><li>Use <code>Math.floor()</code> to ensure the middle index is an integer.</li><li>Show how adjusting <code>low</code> and <code>high</code> reduces the search space.</li></ul><p><strong>Time Complexity of Binary Search:</strong></p><ul><li><strong>O(log n)</strong>: Binary search cuts the array in half each time, making it much more efficient than linear search for large datasets.</li></ul></li><li><p><strong>Binary Search (Recursive Implementation) (5 minutes)</strong></p><p><strong>Introduction to Recursion:</strong>
Explain that recursion involves a function calling itself, breaking down the problem into smaller pieces.</p><p><strong>Code Example:</strong></p><pre class="!overflow-visible"><div class="dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative"><div class="flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9">javascript</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center py-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy code</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearchRecursive</span>(<span class="hljs-params">arr, target, low = <span class="hljs-number">0</span>, high = arr.length - <span class="hljs-number">1</span></span>) {
    <span class="hljs-keyword">if</span> (low &gt; high) {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// Base case: target not found</span>
    }

let mid = Math.floor((low + high) / 2);

if (arr[mid] === target) {
    return mid; // Target found
} else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, high); // Search right half
} else {
    return binarySearchRecursive(arr, target, low, mid - 1); // Search left half
}

}

<span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">binarySearchRecursive</span>(numbers, <span class="hljs-number">7</span>)); <span class="hljs-comment">// Output: 6</span>
</code></div></div></pre><p><strong>Walkthrough:</strong></p><ul><li>The function calls itself with updated <code>low</code> or <code>high</code> values, depending on whether the target is greater or smaller than the middle element.</li><li>Once the base case is reached (when <code>low</code> is greater than <code>high</code>), the recursion stops.</li></ul><p><strong>Pros and Cons of Recursion:</strong></p><ul><li><strong>Pros:</strong><ul><li>Easier to read and understand for smaller problems.</li></ul></li><li><strong>Cons:</strong><ul><li>Can be less efficient in practice due to overhead from repeated function calls.</li></ul></li></ul></li><li><p><strong>Edge Cases (3 minutes)</strong></p><ul><li><strong>What happens if the target isn't in the array?</strong>
Both implementations return <code>-1</code> if the target is not found.</li><li><strong>What happens if the array is empty?</strong>
In this case, <code>low</code> will be greater than <code>high</code>, and the function will immediately return <code>-1</code>.</li><li><strong>What if there are duplicate elements in the array?</strong>
Binary search will return the index of the first instance it encounters (which depends on how the array is divided).</li></ul><p><strong>Edge Case Example:</strong></p><pre class="!overflow-visible"><div class="dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative"><div class="flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9">javascript</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center py-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy code</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">binarySearch</span>(numbers, <span class="hljs-number">4</span>)); <span class="hljs-comment">// Output: 3 (or 4, depending on the implementation)</span>
</code></div></div></pre></li><li><p><strong>Conclusion and Practice Problems (2 minutes)</strong></p><ul><li><strong>Recap:</strong><ul><li>Binary search divides the search space in half, making it efficient for sorted arrays.</li><li>Discuss the difference between iterative and recursive solutions.</li><li>Emphasize the O(log n) time complexity compared to linear searchâ€™s O(n).</li></ul></li><li><strong>Practice Questions:</strong><ol><li>Implement binary search on an array of strings.</li><li>Modify the function to return all indices of a target number if there are duplicates in the array.</li></ol></li><li><strong>Homework:</strong>
Have students implement binary search in another programming language or adapt the function to handle a descending sorted array.</li></ul></li></ol><p>By the end of this class, your students will understand how binary search works, how to implement it both iteratively and recursively, and how to handle edge cases. They will also see the efficiency of this method compared to linear search.</p>